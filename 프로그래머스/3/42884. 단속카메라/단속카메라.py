'''
모든 차량이 한 번은 단속용 카메라를 만나게 하려면 최소 몇 대의 카메라를 설치해야 하는지 
각 차들의 경로의 교집합에 설치해야 함 

routes를 돌면서 가장 많이 겹친 곳에다가 카메라 설치
카메라에 찍힌 차들은 빼버리기
남은 차들의 경로 중 가장 많이 겹친 곳에다가 카메라 설치
카메라에 찍힌 차들은 빼버리기
남은 차가 없을 때까지 반복 

카메라의 max값은 차량 대수 만큼 -> 몇 개를 제거할 수 있는지? 

다 겹치는 부분을 확인하는 건 말이 안되는 것 같은데.... 
-30000부터 30000까지 리스트를 만들어 놓고 표시하지 말고,
주어진 차들의 경로만 표시하면 어떨까? 

===============================================

주어진 route들이 진입-진출 순서인지는 상관 없음 -> 그 경로에 들어왔다가 나갔다는 것이므로
각 route의 안에 최소 하나는 무조건 카메라가 있어야 함
오름차순으로 정렬했다는 가정 하에, 첫 번째 route의 가장 끝 지점에 카메라가 있어야 최대한 많은 경로와 겹칠 수 있음 
1. route들을 sort 해서 오름차순으로 정렬
2. (필요시) -30000은 계산하기 어려우므로 30000을 더해서 0부터 60000으로 만들기
3. 처음 카메라가 설치된 위치를 임의로 설정 (ex. -100)
4. route를 0과 가까운 순서대로 돌면서 그 안에 카메라가 없으면 가장 끝 자리에 카메라를 위치(∵ 최대한 많은 범위와 겹치도록)
5. 범위 안에 이미 카메라가 있으면 pass하기
6. routes의 마지막까지 반복 
'''

def solution(routes):
    cnt = 0           # 카메라 개수를 셀 변수 선언 
    positions = []    # 카메라 위치를 저장할 리스트 
    
    # 1. routes를 진출로 기준 오름차순으로 sort 
    routes.sort(key=lambda x:x[1])
    # print(f'sorted_routes: {routes}')

    # 2. 처음 변수 설정
    camera = -60000      # 첫 카메라 설치 지점 (범위 외)
    # latest_end = -60000  # 직전 route의 종료 지점을 저장할 변수 
    
    # 3. route를 하나씩 돌며 조건에 맞게 카메라 위치 지정 
    for route in routes:
        
        # 카메라가 이미 경로 내에 있으면 pass 
        if route[0] <= camera: 
            # print(f'{i}번 route를 두번째에서 건너뜀 {positions}')            
            continue
        
        # 카메라가 경로 내에 없으면 새로 설치
        else:
            camera = route[1]
            cnt += 1

    answer = cnt
    return answer