'''
최후까지 남기는 것이 가능한 풍선들의 개수 
더 작은 풍선을 터트리는 행위는 최대 1번만 

일단 양쪽 끝에 위치한 풍선들은 최후까지 남을 것

a의 모든 수가 서로 다르므로,
서로 다른 두 개의 풍선을 고르면 반드시 큰 쪽과 작은 쪽이 생김 

어느 한 지점을 선택했을 때, 그 지점의 왼쪽과 오른쪽은 하나의 수로 정리 가능함
그 하나의 수는 왼쪽과 오른쪽에 있던 숫자들 중 가장 작은 수일것 (∵더 큰 수만 터트린다고 가정)
    왼  선택  오른
1.  큼        큼   => 남기기 가능
2.  큼       작음  => 남기기 가능
3.  작음      큼   => 남기기 가능
4.  작음     작음  => 남기기 불가능 

따라서 선택한 수가 마지막까지 남으려면 최소한 한 방향에서 최솟값이어야 함 

[다시 풀기]
한 수에 대해서 좌측에서 최소인지/우측에서 최소인지를 확인하는 것이 아니라
좌->우로 진행하면서 최소값 다 세고
우->좌로 진행하면서 최소값 다 세기 
'''
def solution(a):
    n = len(a)
    # 양쪽 끝의 수는 무조건 가능
    # a[1]번 부터 a[n-2]번까지 원소를 하나씩 검사
    # 1) a[0:i+1] 에서 a[i]가 최솟값이면 ans+=1하고 다음 i로 
    # 2) 1)이 거짓일 경우 a[i:n]에서 a[i]가 최솟값이면 ans+=1하고 다음 i로 
    # 3) 1)과 2)를 다 만족하지 않으면 a[i]는 불가능하므로 다음 i로 
    
    last = 0  # 최후까지 남은 풍선의 수 
    
    min_left = 10e9  # 왼쪽/오른쪽의 최소값 설정 
    min_right = 10e9
    
    check = [0] * n  # 최솟값인지 확인 위한 배열
    
    for i in range(n):
        
        # 좌 -> 우로 진행
        if a[i] < min_left:
            min_left = a[i]
            check[i] = 1
            
        # 우 -> 좌로 진행
        if a[n-1-i] < min_right:
            min_right = a[n-1-i]
            check[n-1-i] = 1
            
    answer = sum(check)
    return answer